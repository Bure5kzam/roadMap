---
layout: roadmap-modal
title: 프로세스
date: 2023-02-11 23:37
author: 
tags: [devops, linux, process]
summary: 
DOM-id: exampleModal3
---

> 글 내에서 운영체제 스케쥴링에 대한 언급이 없을 경우 싱글 프로세서, 멀티 프로그래밍, 멀티 태스킹 기반의 설명이라고 생각해주시면 됩니다.

## 프로세스란

프로세스를 정의하면 실행된 프로그램이라 할 수 있습니다.

코드로 저장만 되어있는 프로그램을 실행시키면 메모리에 적재되어 CPU 같은 논리연산 장치나 마우스, 키보드 같은 입력 장치와 상호작용을 할 수 있게 되며 이를 프로세스라고 부릅니다.

프로세스는 CPU의 코어가 처리할 수 있는 단위이기도 합니다.

CPU는 처리할 프로세스들이 들어있는 `Scheduling queue`에서 우선순위가 높은 것부터 가져와 처리하는데, 코어가 4개인 CPU라면 한번에 4개의 프로세스를 처리할 수 있습니다.

## 컨텍스트 스위칭

cpu는 고급 자원입니다. 연산이 필요한 프로세스들은 많지만 연산장치는 적어서 여러 프로세스들이 돌아가며 사용하게 됩니다.

멀티 프로그래밍 시스템에서 사람이 보기엔 여러 프로세스들이 동시 실행되는 것처럼 보이지만, 하드웨어에서는 하나의 쓰레드가 하나의 프로세스 밖에 처리할 수 없기 때문에 OS가 중간에서 프로세스들이 돌아가며 CPU를 사용할 수 있도록 우선순위를 정하고 스케쥴링을 합니다. 

![스위치 컨텍스트](/docs/assets/img/linux/프로세스-스위치컨텍스트.png)

cpu가 프로세스를 처리하려면 '소스코드를 어디까지 실행했는지' 등을 알아야 하는데, 이는 프로세스마다 다르기 때문에 프로세스가 바뀔 때마다 함께 레지스터에 불러와야 합니다. 이렇게 불러오면서 생기는 지연 현상을 `Context switching`이라고 합니다.

## PCB

PCB는 OS가 프로세스를 스케쥴링하는데 필요한 정보를 저장할 수 있는 **데이터 타입**입니다.

프로세스가 생성되면 OS는 프로세스 스케쥴링에 필요한 정보를 보유하기 위해 다음 순서로 PCB를 생성합니다.

1. OS는 PCB를 생성해 프로세스들에게 할당합니다.
2. 메모리로부터 프로세스가 사용할 공간을 할당받습니다.
3. PCB를 초기화합니다.

PCB를 할당받은 프로세스는 `scheduling queue`에 추가되어 자신이 연산장치를 처리할 차례를 기다립니다.

프로세서가 프로세스를 처리하다가 모종의 이유로 중단하고 다른 프로세스를 처리해야 할 경우, PCB는 진행상태를 임시로 저장하고 나중에 복원하게 해주는 역할을 합니다. OS는 처리 하던 프로세스의 진행상태를 PCB에 저장했다가, 나중에 우선순위가 높아졌을 때 PCB에서 다시 불러와서 처리합니다.

프로세스가 종료되면 PCB도 할당 해제됩니다.

### 메모리 공간 할당

PCB를 생성한 뒤 OS는 프로세스를 위해 메모리로부터 데이터를 저장할 수 있는 공간을 할당받습니다.

OS는 할당받은 메모리 공간을 효율적으로 사용하기 위해 4 섹션으로 나눠서 프로세스 데이터를 저장합니다.

- 프로그램 코드. `text section`이라고 부릅니다.
- 프로그램의 전역 변수와 static 변수가 있는 `data section`
- 일시적인 데이터를 갖는 `Stack`
  - Function 파라미터
  - 복귀 주소
  - 로컬 변수
- 런 타임 동안 동적으로 할당된 메모리 공간인 `Heap` 공간
- 현재 활동 상태. 실행 중인 소스코드를 타나내는 `program counter` 나, `process registers` 등이 포함됨.
- 
 <!-- 프로세스들이 계산됨에 따라, OS는 PCB를 큐에서 큐로 옮기고, 프로세스가 종료되었을 때 결국 OS는 PCB를 할당 해제 합니다.

OS는 프로세스가 실행되고 있지 않을 때 프로세스 실행 상태에 대한 모든 정보를 PCB나 연결된 곳에 유지합니다.

- PC, register
- 프로세스가 스케쥴링되지 않을 때, 프로세스 상태는 하드웨어에서 PCB로 이동됩니다.
- 프로세스가 실행중일 때, 상태는 PCB와 CPU 사이에서 분산됩니다.

간다하게 말하면, 우리는 우리의 컴퓨터 프로그램을 텍스트 파일에 쓰고, 이를 실행하면 프로그램에 언급된 모든 테스크를 수행하는 프로세스가 됩니다.

PCB는 프로세스를 추적하는데 필요한 모든 정보를 유지합니다.


**PCB의 구성**

- PID
- Process status
- Program counter

| ID                            | Name                                      |
| ----------------------------- | ----------------------------------------- |
| PID                           | 프로세스에 부여되는 자연수                |
| Process statue                | New, ready, running, waiting, termined    |
| Program counter               | 다음 실행될 지시문 주소                   |
| CPU registers                 | Stack pointer, general-purpose register   |
| CPU scheduling information    | 프로세스 우선순위                         |
| Memory-management information | Page table, segment table                 |
| Accounting information        | CPU 사용량                                |
| I/O status information        | 프로세스에서 연 파일, 할당된 입/출력 기기 |
 

리눅스의 PCB는 C 구조체 task_struct로 표현됩니다 이는 프로세스를 표현하는데 필수적인 모든 정보를 포함합니다. (프로세스의 상태, 스케쥴링과 메모리 관리 정보, 열려있는 파일 목록과 부모 프로세스를 가리키는 포인터 등.. 약 100개의 필드가 있음).

리눅스 커널 내에, 모든 활성 프로세스는 task_struct의 이중 링크드 리스트를 사용해 표현되며, 시스템 내 현재 실행 중인 프로세스들에 대한 포인터를 유지합니다. -->


<!-- ## OS에서의 프로세스

### PCB 생성

프로세스가 실행되면 먼저, OS는 PCB를 생성합니다.

PCB는 프로세스에 대한 정보를 담기 위한 데이터 구조로, 현재 실행되고 있는 프로세스를 추적하는데 필요한 정보를 갖고 있습니다. (약 100개의 필드가 있습니다.)

**PCB 데이터의 일부**


| ID                            | Name                                      |
| ----------------------------- | ----------------------------------------- |
| PID                           | 프로세스에 부여되는 자연수                |
| Process statue                | New, ready, running, waiting, termined    |
| Program counter               | 다음 실행될 지시문 주소                   |
| CPU registers                 | Stack pointer, general-purpose register   |
| CPU scheduling information    | 프로세스 우선순위                         |
| Memory-management information | Page table, segment table                 |
| Accounting information        | CPU 사용량                                |
| I/O status information        | 프로세스에서 연 파일, 할당된 입/출력 기기 |


생성해 프로세스에 대한 정보를 기록합니다.
 -->




<!-- ## Scheduling queue -->



## 프로세스의 생성과 삭제

시스템은 첫 프로세스를 생성합니다. (유닉스에서는 syproc)

생성된 프로세스들은 후속 프로세스들을 생성하는데, 다음과 같은 단어를 사용합니다.

- 프로세스를 생성한 프로세스를 parent process라고 합니다.
- 생성된 프로세스는 child process라고 합니다.
- parent와 child 관계는 process tree로 표현될 수 있습니다.

유닉스에서, 두 번째 프로세스는 `init`라고 부릅니다.

- 모든 로그인 프로세스들과 데몬을 생성합니다. (gettys 라고 부름)
- 꺼지지 않습니다.
- 시스템 설정을 제어합니다 (프로세스 개수, 우선순위 등)

유닉스 시스템 인터페이스는 프로세스를 생성하는 fork 시스템 콜을 포함하고 있습니다. '

### fork

`fork`는 새 PCB를 생성 및 초기화하고, 부모 주소 공간의 전체 컨텐츠 복사본과 함께 새 주소 공간을 생성합니다. 이 새로운 PCB는 `ready queue`에 배치됩니다.

`fork()`는 자식 프로세스를 생성하며 다음을 상속합니다.

- 모든 부모의 변수, 메모리의 동일한 복사본
- 모든 부모의 CPU 레지스터 (하나는 예외) 동일한 복사본

`fork()` 시스템 콜은 값을 두번 반환합니다. 한번은 부모에서, 다른 한번은 자식에서.

- 부모에게는 자식의 PID를 반환합니다.
- 자식에게는 0을 반환합니다.

그러므로 `fork()`는 clone me의 의미와 같습니다.

- 자식 프로세스를 위해 메모리를 할당합니다.
- 부모의 메모리와 CPU 레지스터를 자식에게 복사합니다.

### exec

`exec()`는 프로세스가 다른 프로그램을 적재하게 해주고 `at_start` 실행을 시작하게 해줍니다. (새 프로세스를 시작하는 것이 아님)

프로세스가 몇개의 인자(argc)와 문자열 인자 배열(argv)를 지정하게 해줍니다.

만약 호출이 성공적이라면 : 같은 프로세스지만 다른 프로그램을 실행하게 되는 것입니다!

## 프로세스의 종료

프로세스는 마지막 구문을 실행하고 OS에게 삭제해달라고 스스로 요청합니다 (exit)

- 자식 프로세스는 부모에게 상태값을 반환합니다 (wait)
- 자식 프로세스의 리소스가 os에 의해 할당 해제됩니다.

부모는 자식 프로세스의 실행을 종료합니다 (abort)

- 만약 자식이 할당된 리소스를 초과햇을 때
- 자식에게 할당된 테스크가 더 이상 요구되지 않을 때


어떤 OS는 부모가 종료되었을 때 자식이 존재하는 것을 허용하지 않습니다. 만약 프로세스가 종료되면, 해당 프로세스의 자식들도 종료되어야 합니다.(cascading termination)

부모 프로세스는 `wait` 시스템 콜로 자식 프로세스가 종료되기까지 기다립니다.
호출은 상태 정보와 종료된 프로세스의 pid를 반환합니다.
- pid - wait(&status)

만약 기다리는 부모가 없으면 (did not invoke wait()) 이 자식 프로세스는 zombie가 됩니다.
만약 부모 프로세스가 wait없이 종료되었다면, 이 자식 프로세스는 orphan가 됩니다.


## 포스트

### Concept

- 태초의 프로세스
- 프로세스의 상태
- 컨텍스트 스위칭이 발생하는 트리거와 동작
- 
- OS에서 프로세스를 관리하는 방법
- 프로세스와 관련된 시스템콜
- 우분투 프로세스 fork와 exec
- 우분투 실행중인 프로세스 모니터링